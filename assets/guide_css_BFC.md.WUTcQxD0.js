import{_ as t,o as i,c as l,R as o}from"./chunks/framework.5IuVB3YY.js";const s="/study_blog.github.io/assets/KFC.C_iX-C_M.png",a="/study_blog.github.io/assets/son-float.Zz2thjWc.png",e="/study_blog.github.io/assets/out-float.5Rca9N2z.png",r="/study_blog.github.io/assets/margin.3CN8a0UU.png",h=JSON.parse('{"title":"BFC块","titleTemplate":"CSS基础","description":"","frontmatter":{"title":"BFC块","titleTemplate":"CSS基础"},"headers":[],"relativePath":"guide/css/BFC.md","filePath":"guide/css/BFC.md"}'),F={name:"guide/css/BFC.md"},C=o('<h1 id="bfc-块" tabindex="-1">BFC 块 <a class="header-anchor" href="#bfc-块" aria-label="Permalink to &quot;BFC 块&quot;">​</a></h1><p>BFC 块是 CSS 中的重要知识点，英语全称 Block formatting contexts，翻译成中文就是“<strong>块级格式化上下文</strong>”。本文将对其规则，作用进行研究，并简单介绍 IFC、GFC 和 FFC。</p><h2 id="什么是-bfc-块" tabindex="-1">什么是 BFC 块 <a class="header-anchor" href="#什么是-bfc-块" aria-label="Permalink to &quot;什么是 BFC 块&quot;">​</a></h2><p>首先，它和 KFC 没有任何关系。<br> 其次，它和 KFC 没有关系。<br> 最后，它和KFC 没有关系。 <img src="'+s+'" alt="KFC" title="KFC"></p><p><strong>BFC（Block formatting contexts）是块级格式上下文，它是一块独立的渲染区域，它规定了<em>常规流块盒</em> 的在该区域的布局方式</strong>。是视觉格式化模型中的一套渲染规则。</p><ol><li><p>首先介绍一下是常规流块盒，也就是通常状态下的块盒，它的布局将根据以下规则：</p><ul><li>常规流块盒在水平方向上，必须撑满包含块。</li><li>常规流块盒在包含块的垂直方向上依次摆放。</li><li>常规流块盒若外边距无缝相邻，则进行外边距合并。</li><li>常规流块盒的自动高度和摆放位置，无视浮动元素。</li></ul></li><li><p><strong>BFC 在其独立的渲染区域内，有另外一套布局规则</strong>:</p><ul><li>创建 BFC 的元素，隔绝了它内部和外部的联系，内部的渲染不会影响到外部。</li><li>创建 BFC 的元素，它的自动高度需要计算浮动元素（包含内部浮动）。</li><li>创建 BFC 的元素，它的边框盒子不会与浮动元素重叠（排除外部浮动）。</li><li>创建 BFC 的元素，它不会和其他元素进行外边距合并（阻止外边距重叠）</li></ul></li><li><p>BFC 渲染区域：这个区域由某个 HTML 元素创建，以下元素会在其内部创建 BFC 区域：</p><ul><li>根元素</li><li>浮动元素</li><li>绝对定位元素（position 值为 absolute 或 fixed 的元素）</li><li>overflow 不等于 visible 和 clip 的块盒</li><li>display 为 flow-root 的元素</li></ul><p>当然，能创建 BFC 独立渲染区域的方式并不止以上几种，<strong>该区域指的是元素内部，并不包括元素本身</strong>，也就是如果希望自身也适应 BFC 规则，应当将自身的父级块盒也设置成 BFC 块。</p></li><li><p>上面提到了 display 为 flow-root 的元素也会生成 BFC。flow-root 表示跟随根元素，而根元素，本身就是一个 BFC 块，与其他创建 BFC 块的方式不同，这种方式是存粹的，<strong>它不会附加任何副作用</strong>。</p></li></ol><h2 id="bfc-的常见作用" tabindex="-1">BFC 的常见作用 <a class="header-anchor" href="#bfc-的常见作用" aria-label="Permalink to &quot;BFC 的常见作用&quot;">​</a></h2><p>我们可以利用 BFC 其特殊的布局规则，实现更优的布局或是处理常规流块盒的弊端</p><ol><li><p>解决浮动元素令父元素高度坍塌的问题<br> 当一个父元素（常规流块盒）中，子元素被设置了浮动，导致父元素<strong>自动计算高度</strong>时，没有把子元素高度计算进去，会呈现出高度坍塌的效果。<strong>可以将父元素设置为 BFC 块，使其在计算高度时，将浮动的子元素高度计算在内</strong>。</p><p><img src="'+a+'" alt="子元素浮动" title="子元素浮动"></p></li><li><p>解决非浮动元素被浮动元素覆盖问题<br> 当兄弟元素（常规流块盒）中，其中一个设置了浮动，导致兄弟元素重叠，也就是兄弟元素的上边框和左边框重叠在一起。<strong>可以将其中未浮动的兄弟元素设置为 BFC 块，使其边框盒子不与浮动元素重叠</strong>。</p><p><img src="'+e+'" alt="外部浮动" title="外部浮动"></p></li><li><p>解决外边距垂直方向重合的问题<br> 当兄弟元素（常规流块盒）中，上方的元素设置了下边距，下方的元素设置了上边距，则会进行外边距合并，取二者中最大的边距，会呈现出高度减少的效果。<strong>可以将其中任意兄弟元素设置为 BFC 块，使其不与其他元素进行外边距合并</strong>。</p><p><img src="'+r+'" alt="外边距" title="外边距"></p></li></ol><h2 id="ifc、gfc-和-ffc" tabindex="-1">IFC、GFC 和 FFC <a class="header-anchor" href="#ifc、gfc-和-ffc" aria-label="Permalink to &quot;IFC、GFC 和 FFC&quot;">​</a></h2><p>除了文中讨论的 BFC 之外，视觉格式化模型中还存在其他的布局规则，例如 IFC、GFC 和 FFC。</p><ul><li>IFC：行内格式化上下文，将一块区域以行内元素的形式来格式化。</li><li>GFC：网格布局格式化上下文，将一块区域以 grid 网格的形式来格式化。</li><li>FFC：弹性格式化上下文，将一块区域以弹性盒的形式来格式化。</li></ul><p>以 FFC 为例，设置 display 为 flex 的元素，会在其内部生成 FFC 弹性格式上下文。</p><p>有的文章说弹性盒能生成 BFC 是不严谨的，<strong>弹性盒内部生成的是 FFC，它的子元素内部生成的才是 BFC，前提是子元素没有被生成其他盒</strong>，假设弹性盒中的子元素也是弹性盒，那么，子元素内部生成的 FFC，而不是 BFC。</p>',14),n=[C];function p(c,g,_,B,d,f){return i(),l("div",null,n)}const b=t(F,[["render",p]]);export{h as __pageData,b as default};
