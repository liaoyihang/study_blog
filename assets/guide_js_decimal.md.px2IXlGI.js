import{_ as t,o as e,c as l,R as i}from"./chunks/framework.5IuVB3YY.js";const n="/study_blog.github.io/assets/IEEE-754(64位).PVpmyK0A.png",s="/study_blog.github.io/assets/转浮点数示例.pJYLYZLB.png",E=JSON.parse('{"title":"浮点数原理","titleTemplate":"JS基础","description":"","frontmatter":{"title":"浮点数原理","titleTemplate":"JS基础"},"headers":[],"relativePath":"guide/js/decimal.md","filePath":"guide/js/decimal.md"}'),a={name:"guide/js/decimal.md"},r=i(`<h1 id="浮点数原理" tabindex="-1">浮点数原理 <a class="header-anchor" href="#浮点数原理" aria-label="Permalink to &quot;浮点数原理&quot;">​</a></h1><p>本文将从<strong>浮点数</strong>的经典案例入手，去研究<strong>浮点数的存储原理</strong>、<strong>IEEE754 浮点数标准</strong>、<strong>浮点数转换规则</strong>、<strong>浮点数精度丢失</strong>的相关知识。</p><h2 id="_0-1-0-2-0-3" tabindex="-1">0.1 + 0.2 === 0.3 ? <a class="header-anchor" href="#_0-1-0-2-0-3" aria-label="Permalink to &quot;0.1 + 0.2 === 0.3 ?&quot;">​</a></h2><p>在 JS 中，有一个与常识不符的现象，0.1 + 0.2 === 0.3 的结果是 false，也就是说我们在 JS 中看到的小数，是存在精度丢失的，可以通过 toPrecision 函数，来查看实际的数字。例如，0.1的实际存储为 0.1000000000000000055511151231257827021181583404541015625。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.3</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toPrecision</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;0.1000000000000000055511151231257827021181583404541015625&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toPrecision</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;0.2000000000000000111022302462515654042363166809082031250&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toPrecision</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;0.2999999999999999888977697537484345957636833190917968750&#39;</span></span></code></pre></div><h2 id="浮点数" tabindex="-1">浮点数 <a class="header-anchor" href="#浮点数" aria-label="Permalink to &quot;浮点数&quot;">​</a></h2><p>在代码中声明的数，会转换成二进制存储在计算机中，<strong>浮点数</strong>是计算机中用来存储小数的一种方式，表示不约定小数点的位置，小数点位置是漂浮不定的，与之对应的是<strong>定点数</strong>。<br> 浮点数用来表示数的规则如下:</p><blockquote><p>V = (-1)^S * M * R^E</p></blockquote><p>参数含义如下：</p><ul><li>S：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负</li><li>M：尾数，用小数表示，例如前面所看到的 0.2 * 10^0，0.2 就是尾数</li><li>R：基数，表示十进制数 R 就是 10，表示二进制数 R 就是 2</li><li>E：指数，用整数表示，例如前面看到的 0.2 * 10^0，0 即是指数</li></ul><h2 id="ieee754-浮点数标准" tabindex="-1">IEEE754 浮点数标准 <a class="header-anchor" href="#ieee754-浮点数标准" aria-label="Permalink to &quot;IEEE754 浮点数标准&quot;">​</a></h2><p>IEEE754 浮点数标准是 IEEE 组织推出了浮点数标准，这个标准统一了浮点数的表示形式，并提供了 2 种浮点格式：</p><ul><li>单精度浮点数 float：32 位，符号位 S 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit</li><li>双精度浮点数 float：64 位，符号位 S 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit</li></ul><p>计算机中的存储方式遵循 IEEE754 浮点数计数标准，即符号（S）、阶码部分（E）、尾数部分（M），可以表示为：</p><blockquote><p>1.M * 2^E</p></blockquote><p>双精度浮点数（64位）示例图： <img src="`+n+'" alt="64位示例" title="64位示例"></p><h2 id="数转浮点数" tabindex="-1">数转浮点数 <a class="header-anchor" href="#数转浮点数" aria-label="Permalink to &quot;数转浮点数&quot;">​</a></h2><p>例如，一个数，520.1314，将它转换成二进制浮点数，以64位为例</p><p>可以确定的是符号位S一定0，基数一定是2，其整数部分为520，计算为除2取余，过程如下:</p><table><thead><tr><th style="text-align:center;">计算</th><th style="text-align:center;">结果</th><th style="text-align:center;">余数</th></tr></thead><tbody><tr><td style="text-align:center;">520/2</td><td style="text-align:center;">260</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">260/2</td><td style="text-align:center;">130</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">130/2</td><td style="text-align:center;">65</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">65/2</td><td style="text-align:center;">32</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">32/2</td><td style="text-align:center;">16</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">16/2</td><td style="text-align:center;">8</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">8/2</td><td style="text-align:center;">4</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">4/2</td><td style="text-align:center;">2</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">2/2</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">1/2</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td></tr></tbody></table><p>计算结果从左往右以此是 1000001000</p><p>其小数部分为1314，计算为乘2取整，过程如下:</p><table><thead><tr><th style="text-align:center;">计算</th><th style="text-align:center;">结果</th><th style="text-align:center;">余数</th></tr></thead><tbody><tr><td style="text-align:center;">0.1314*2</td><td style="text-align:center;">0.2628</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.2628*2</td><td style="text-align:center;">0.5256</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.5256*2</td><td style="text-align:center;">1.0512</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">0.0512*2</td><td style="text-align:center;">0.1024</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.1024*2</td><td style="text-align:center;">0.2048</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.2048*2</td><td style="text-align:center;">0.4096</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.4096*2</td><td style="text-align:center;">0.8192</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.8192*2</td><td style="text-align:center;">1.6384</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">0.6384*2</td><td style="text-align:center;">1.2768</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">0.2768*2</td><td style="text-align:center;">0.5536</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.5536*2</td><td style="text-align:center;">1.1072</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">0.1072*2</td><td style="text-align:center;">0.2144</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.2144*2</td><td style="text-align:center;">0.4288</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.4288*2</td><td style="text-align:center;">0.8576</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.8576*2</td><td style="text-align:center;">1.7152</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">0.7152*2</td><td style="text-align:center;">1.4304</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">0.4304*2</td><td style="text-align:center;">0.8608</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">0.8608*2</td><td style="text-align:center;">1.7216</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">0.7216*2</td><td style="text-align:center;">...</td><td style="text-align:center;">...</td></tr></tbody></table><p>计算结果从左往右以此是 001000011010001101...，是一个无限不循环数</p><p>合并结果以后：1000001000.001000011010001101... * 2^0</p><p>写成 1.M * 2^E 的格式为：1.000001000001000011010001101... * 2^9</p><p>E 加上偏移位 1023，最终结果位 1023 + 9 = 1032，转换为二进制后 10000001000</p><blockquote><p>1023 即二进制的 1111111111，共10位，因为指数也需要考虑正负，所以通过 E-1023 来表示指数位，可表示范围为 [-1023, 1024]<br> 当 E 为 2047 ，即 11111111111 时，也就是11位都是1时，指数为 2047 - 1023 = 1024<br> 当 E 为 0 ，即 0 时，指数为 0 - 1023 = -1023<br> 同理，32位 也存在偏移位，为 127，可表示范围位 [-127, 128]</p></blockquote><p>通过专门的转浮点数工具校验一下</p><blockquote><p>在线解析AST网址：<a href="https://www.toolhelper.cn/Digit/FractionConvert" target="_blank" rel="noreferrer">https://www.toolhelper.cn/Digit/FractionConvert</a></p></blockquote><p><img src="'+s+'" alt="转浮点数示例" title="转浮点数示例"></p><p>对比计算结果与工具计算结果：</p><table><thead><tr><th style="text-align:center;">计算方式</th><th style="text-align:center;">S</th><th style="text-align:center;">E</th><th style="text-align:left;">M</th></tr></thead><tbody><tr><td style="text-align:center;">公式</td><td style="text-align:center;">0</td><td style="text-align:center;">10000001000</td><td style="text-align:left;">000001000001000011010001101...</td></tr><tr><td style="text-align:center;">工具</td><td style="text-align:center;">0</td><td style="text-align:center;">10000001000</td><td style="text-align:left;">0000010000010000110100011011011100010111010110001110</td></tr></tbody></table><p>虽然没有计算完全部，但经过比对，计算出来的位数与工具计算结果一致。</p><h2 id="浮点数精度丢失原因" tabindex="-1">浮点数精度丢失原因 <a class="header-anchor" href="#浮点数精度丢失原因" aria-label="Permalink to &quot;浮点数精度丢失原因&quot;">​</a></h2><p>在上面的计算过程中也不难发现，乘2取整的结果，基本上是无限的，而存储的位数确是有限的，此时会截取存储，进而导致了浮点数精度丢失。回到最初的问题，为什么 0.1 + 0.2 === 0.3 是 false？</p><ol><li>在 JavaScript 中，所有的 Number 都是以64位的双精度浮点数存储的</li><li>浮点数是根据 IEEE754 浮点数标准存储在计算机中</li><li>小数部分的转换规则是乘2取整，通常情况下是无限循环数或无限不循环数，而计算机的存储位数为32位和64位，是有限的，存储无限数时会发生截取，必定会有一定的精度损失</li><li>不仅 javascript，所有遵循 IEEE 754 规范的语言都是如此</li></ol>',37),d=[r];function c(g,h,p,y,o,x){return e(),l("div",null,d)}const b=t(a,[["render",c]]);export{E as __pageData,b as default};
