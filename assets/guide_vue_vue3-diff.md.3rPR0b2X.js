import{_ as e,o as i,c as l,R as a}from"./chunks/framework.5IuVB3YY.js";const t="/study_blog.github.io/assets/sync-from-start.xyAYjOqC.png",o="/study_blog.github.io/assets/sync-from-end._M5oc30u.png",n="/study_blog.github.io/assets/common-sequence-mount.Bg5k6vqO.png",r="/study_blog.github.io/assets/common-sequence-unmount.MfSqP6Rl.png",s="/study_blog.github.io/assets/unknown-sequence.t2pxLqy9.png",k=JSON.parse('{"title":"Vue diff 算法解析","titleTemplate":"Vue","description":"","frontmatter":{"title":"Vue diff 算法解析","titleTemplate":"Vue"},"headers":[],"relativePath":"guide/vue/vue3-diff.md","filePath":"guide/vue/vue3-diff.md"}'),d={name:"guide/vue/vue3-diff.md"},c=a('<h1 id="vue-diff-算法" tabindex="-1">Vue diff 算法 <a class="header-anchor" href="#vue-diff-算法" aria-label="Permalink to &quot;Vue diff 算法&quot;">​</a></h1><p><strong>Diff 算法是 Vue 用于减少真实 Dom 渲染的一种算法，它通过对比新旧虚拟 Dom 树，尽最大可能保留相同节点，找出不同的节点，并将不同的节点 patch 到真实 Dom 上</strong>。</p><h2 id="为什么需要-diif-算法" tabindex="-1">为什么需要 diif 算法 <a class="header-anchor" href="#为什么需要-diif-算法" aria-label="Permalink to &quot;为什么需要 diif 算法&quot;">​</a></h2><p>通过虚拟DOM改变真正的 DOM 并不比直接操作 DOM 效率更高。恰恰相反，我们仍需要调用 DOM API 去操作 DOM，并且虚拟 DOM 还会额外占用内存！但是，我们可以通过 虚拟 DOM + diff 算法，找到需要更新的最小单位，最大限度地减少真实 DOM 操作，从而提升性能。</p><ol><li>diff 算法的核心作用是降低渲染器 renderer 的性能消耗。</li><li>diff 算法通过一系列计算，得到真实 DOM 改动最少的操作。</li></ol><h2 id="vue3-diff-算法" tabindex="-1">Vue3 diff 算法 <a class="header-anchor" href="#vue3-diff-算法" aria-label="Permalink to &quot;Vue3 diff 算法&quot;">​</a></h2><p>源码地址：<a href="https://github.com/vuejs/core/blob/main/packages/runtime-core/src/renderer.ts" target="_blank" rel="noreferrer">https://github.com/vuejs/core/blob/main/packages/runtime-core/src/renderer.ts</a></p><ol><li>有两个主要的函数 patchUnkeyedChildren 和 patchKeyedChildren。分别用于不带 key 值的虚拟 Dom 和带 key 值的虚拟 Dom。</li><li>对于 patchUnkeyedChildren 直接采用 remove old（删除老节点）和 mount new（挂载新节点）。</li><li>对于 patchKeyedChildren 则依次采用： <ol><li>sync from start（前序对比）</li><li>sync from end（后序对比）</li><li>common sequence + mount（同序列加挂载）</li><li>common sequence + unmount（同序列加卸载）</li><li>unknown sequence（乱序对比）</li></ol></li></ol><h3 id="术语拓展" tabindex="-1">术语拓展 <a class="header-anchor" href="#术语拓展" aria-label="Permalink to &quot;术语拓展&quot;">​</a></h3><ol><li>i ：对比指针</li><li>c1：旧的孩子节点</li><li>c2：新的孩子节点</li><li>e1：旧孩子的尾指针</li><li>e2：新孩子的尾指针</li><li>old：旧虚拟节点序列</li><li>new：新虚拟节点序列</li><li>s1：未知序列的旧节点指针</li><li>s2：未知序列的新节点指针</li><li>对比条件：<strong>当虚拟节点的 type 和 key 相同则视为同一节点</strong></li></ol><h3 id="前序对比" tabindex="-1">前序对比 <a class="header-anchor" href="#前序对比" aria-label="Permalink to &quot;前序对比&quot;">​</a></h3><p>指针 i 从前开始向后对比，当新旧虚拟节点不一致，或双方有一方 i 大于尾指针，停止循环。 例如：ab -&gt; abc <img src="'+t+'" alt="前序对比" title="前序对比"> 指针，从 a 开始向后比对，比对至 i = 3 时，i 指针 &gt; 旧孩子尾指针 e1 ,结束。</p><h3 id="后序对比" tabindex="-1">后序对比 <a class="header-anchor" href="#后序对比" aria-label="Permalink to &quot;后序对比&quot;">​</a></h3><p>尾指针 e1 和 e2 从后开始向前对比，当新旧虚拟节点不一致，或双方有一方 i 大于尾指针，停止循环。 例如：ab -&gt; cab <img src="'+o+'" alt="后序对比" title="后序对比"></p><p>旧节点尾指针 e1，从 b 开始向前比对；<br> 新节点尾指针 e2，从 b 开始向前比对； 比对至 e1 = -1 时，i 指针 &gt; 旧孩子尾指针 e1 ,结束。</p><h3 id="同序列加挂载" tabindex="-1">同序列加挂载 <a class="header-anchor" href="#同序列加挂载" aria-label="Permalink to &quot;同序列加挂载&quot;">​</a></h3><p>指针 i 比旧孩子的尾指针 e1 大说明有要新增的，i 和 e2 之间的是新增的节点。 例如：ab -&gt; abc 和 ab -&gt; abcd <img src="'+n+'" alt="同序列加挂载" title="同序列加挂载"></p><h3 id="同序列加卸载" tabindex="-1">同序列加卸载 <a class="header-anchor" href="#同序列加卸载" aria-label="Permalink to &quot;同序列加卸载&quot;">​</a></h3><p>指针 i 比新孩子的尾指针 e2 大说明有要卸载的，i 到 e1 之间的就是要卸载的节点。 例如：abc -&gt; ab <img src="'+r+'" alt="同序列加卸载" title="同序列加卸载"></p><h3 id="乱序对比" tabindex="-1">乱序对比 <a class="header-anchor" href="#乱序对比" aria-label="Permalink to &quot;乱序对比&quot;">​</a></h3><ol><li>经过前序对比和后序对比，如果即不满足【同序列+挂载】，也不【同序列+卸载】，则得到【未知序列】</li><li>旧节点中的未知序列，为 i 至 e1 之间的节点</li><li>新节点中的未知序列，为 i 至 e2 之间的节点</li><li>build key:index map for newChildren （从新节点的未知序列中，构建序号关系 keyToNewIndexMap）</li><li>loop through old children left to be patched and try to patch （从旧节点的未知序列中，对比判断是否存在余 keyToNewIndexMap，不存在则移除，存在则记录二者序号关系 newIndexToOldIndexMap）</li><li>构建 newIndexToOldIndexMap 的最长递增序列 increasingNewIndexSequence（<a href="./increasing-sequence.html">最长递增子序列算法</a>）</li><li>移动并挂载最长递增序列，遍历新节点未知序列， <ol><li>如果其在旧节点未知序列中不存在，则直接新增挂载，</li><li>反之则继续判断，其是否在最长递增序列中， <ol><li>如果存在，则不动，</li><li>如果不存在，则根据二者序号关系，从旧节点未知序列将其移动至新节点序列的对应位置。</li></ol></li></ol></li></ol><h3 id="乱序对比稍微复杂一些-直接带入例子从头开始演示-先补充整体流程" tabindex="-1">乱序对比稍微复杂一些，直接带入例子从头开始演示，先补充整体流程 <a class="header-anchor" href="#乱序对比稍微复杂一些-直接带入例子从头开始演示-先补充整体流程" aria-label="Permalink to &quot;乱序对比稍微复杂一些，直接带入例子从头开始演示，先补充整体流程&quot;">​</a></h3><ol><li>前序对比，当新旧虚拟节点不一致，或双方有一方 i 大于尾指针，跳出前序对比</li><li>后序对比，当新旧虚拟节点不一致，或双方有一方 i 大于尾指针，跳出后续对比</li><li>判断指针 i，和新旧孩子序列的尾指针 e1 和 e2： <ol><li>i &gt; e1 &amp;&amp; i &lt;= e2，则进入同序列 + 挂载</li><li>i &gt; e2 &amp;&amp; i &lt;= e1，则进入同序列 + 卸载</li><li>不满足以上情况，则进入乱序对比</li></ol></li></ol><p>例子：abcdefg -&gt; abxceyfg <img src="'+s+'" alt="乱序对比" title="乱序对比"></p>',24),u=[c];function h(f,m,p,b,g,_){return i(),l("div",null,u)}const x=e(d,[["render",h]]);export{k as __pageData,x as default};
